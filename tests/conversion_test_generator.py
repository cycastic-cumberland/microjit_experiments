#                         type  bit_count
#                          ^     ^
PRIMITIVE_LIST: list[tuple[int, int]] = [
    (0, 8),
    (0, 16),
    (0, 32),
    (0, 64),
    (1, 8),
    (1, 16),
    (1, 32),
    (1, 64),
    (2, 32),
    (2, 64)
]

INDENT = "    "

TEMPLATE_TEXT = '''
// This file is automatically generated

#include <random>
#include <gtest/gtest.h>
#include <microjit/orchestrator.h>

class PrimitiveConversionTestFixture : public ::testing::Test {{
private:
    microjit::Ref<microjit::OrchestratorComponent<microjit::MicroJITCompiler_x86_64, microjit::ThreadSafeObject>> orchestrator{{}};
    std::random_device device{{}};
    std::mt19937 rng{{device()}};
public:
    void SetUp() override {{
        orchestrator = microjit::orchestrator();
    }}
    void TearDown() override {{
        orchestrator = microjit::Ref<microjit::OrchestratorComponent<microjit::MicroJITCompiler_x86_64, microjit::ThreadSafeObject>>::null();
    }}
{}
}};
TEST_F(PrimitiveConversionTestFixture, PrimitiveConversionTest) {{
{}
}}
'''

LIMIT_TABLE = {}

def get_type_name(raw: tuple[int, int]) -> str:
    (type, size) = raw
    if type == 0:
        return f"uint{size}_t"
    if type == 1:
        return f"int{size}_t"
    if size == 32:
        return "float"
    if size == 64:
        return "double"

TEST_METHOD_NAME = "test_{}_to_{}"

def generate_test(f_type: tuple[int, int], t_type: tuple[int, int]):
    (f_name, t_name) = (get_type_name(f_type), get_type_name(t_type))
    (from_min, from_max) = LIMIT_TABLE[f_type]
    re = ""
    re += (INDENT * 1) + f"bool {TEST_METHOD_NAME.format(f_name, t_name)}() {{\n"
    (internal, _) = f_type
    if internal == 2:
        re += (INDENT * 2) + f"static constexpr {f_name} from_val = 3.14159265358979323846;\n"
    else:
        re += (INDENT * 2) + f"std::uniform_int_distribution<{f_name}> dis({from_min}, {from_max});\n"
        re += (INDENT * 2) + f"auto from_val = dis(rng);\n"
    re += (INDENT * 2) + f"static const std::function<{t_name}()> model{{}};\n"
    re += (INDENT * 2) + f"auto instance = orchestrator->create_instance_from_model(model);\n"
    re += (INDENT * 2) + f"auto function = instance->get_function();\n"
    re += (INDENT * 2) + f"auto main_scope = function->get_main_scope();\n"
    re += (INDENT * 2) + f"auto var_from = main_scope->create_variable<{f_name}>();\n"
    re += (INDENT * 2) + f"main_scope->construct_from_immediate<{f_name}>(var_from, from_val);\n"
    re += (INDENT * 2) + f"auto var_to = main_scope->create_variable<{t_name}>();\n"
    re += (INDENT * 2) + f"main_scope->convert<{f_name}, {t_name}>(var_from, var_to);\n"
    re += (INDENT * 2) + f"main_scope->function_return(var_to);\n"
    re += (INDENT * 2) + f"auto to_val = instance();\n"
    re += (INDENT * 2) + f"auto cpp_val = ({t_name})from_val;\n"
    re += (INDENT * 2) + f"instance.detach();\n"
    re += (INDENT * 2) + f"return to_val == cpp_val;\n"
    re += (INDENT * 1) + "}\n"
    return re

def generate_limit_table(l):
    re = {}
    for tup in l:
        (type, size) = tup
        if type == 2:

           re[tup] = ("-100000.0", "100000.0")
           continue
        max_unsigned = pow(2, size) - 1
        if type == 1:
            min = -((max_unsigned + 1) // 2)
            max = -min - 1
            min += 1
            re[tup] = (str(min), str(max))
        else:
            re[tup] = (str(0), str(max_unsigned) + "U")
    return re

LIMIT_TABLE = generate_limit_table(PRIMITIVE_LIST)

def generate_tests():
    n = len(PRIMITIVE_LIST)
    re = ""
    scope = 1
    for i in range(n):
        for j in range(n):
            if i == j: continue
            re += generate_test(PRIMITIVE_LIST[i], PRIMITIVE_LIST[j])
            re += "\n"
    return re

def generate_cases():
    n = len(PRIMITIVE_LIST)
    re = ""
    scope = 1
    for i in range(n):
        for j in range(n):
            if i == j: continue
            (f_name, t_name) = (get_type_name(PRIMITIVE_LIST[i]), get_type_name(PRIMITIVE_LIST[j]))
            test_name = TEST_METHOD_NAME.format(f_name, t_name)
            re += (INDENT * scope) + f"EXPECT_TRUE({test_name}());"
            re += "\n"
    return re

TARGET_FILE = "conversion_test.gen.cpp"

import sys
import os

(dirname, filename) = os.path.split(sys.argv[0])

full_target_path = os.path.join(dirname, TARGET_FILE)

with open(full_target_path, "wt") as f:
    f.write(TEMPLATE_TEXT.format(generate_tests(), generate_cases()))
